/*
 Computador RPM Puma
 Lê os pulsos de Rotações Por Minuto do motor na porta A0 (analógica)
 Calcula o valor de RPM
 Exibe os dados em display mini OLED
 Exibe os dados em leds circulares
 Recebe o valor de velocidade via ESPNOW
 Calcula o RPM ideal para a velocidade dada, e exibe nos leds RPM
 Endereco MAC computador principal: 48:55:19:00:50:DE
 *  
 *  Criar imagens: https://javl.github.io/image2cpp/ 
 *  Code output format  Plain bytes
 *  Draw mode:  Horizontal - 1 bit per pixel
 *  Swap bits in byte:   swap
 *  
 */

#include <ESP8266WiFi.h>
#include <espnow.h>
#include <Wire.h>
#include "SSD1306Wire.h"
#include <SimpleKalmanFilter.h> 

#include <Adafruit_NeoPixel.h>
#define LED_PIN    D4
#define LED_COUNT 18
Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);

SimpleKalmanFilter filtroRpm(2, 2, 0.0001);

#include <SwitecX25.h>

// standard X25.168 range 315 degrees at 1/3 degree steps
#define STEPS (315*3)

// For motors connected to digital pins 4,5,6,7
SwitecX25 motor1(STEPS,D3,D7,D5,D6);
int ponteiro = 0;

int rpmFiltered = 0;
int elasticidade = 5; //define a elasticidade do ponteiro, quanto menor, maior a elasticidade

bool servoIsOn = false;
bool espnowIsOn = true;
bool debugIsOn = true;
bool testIsOn = false;

//Servo myservo;

SSD1306Wire display(0x3c, SDA, SCL);

#define logoPuma64_width 64
#define logoPuma64_height 25
// 'logoPuma64', 64x25px
const unsigned char logoPuma64 [] PROGMEM = {
  0xc7, 0x71, 0x1c, 0xc7, 0x71, 0x1c, 0xc7, 0x71, 0xc7, 0x71, 0x1c, 0xc7, 0x71, 0x1c, 0xc7, 0x71, 
  0xc7, 0x71, 0x1c, 0xc7, 0x71, 0x1c, 0xc7, 0x71, 0x38, 0x8e, 0xe3, 0x38, 0x8e, 0xe3, 0x38, 0x0e, 
  0x38, 0x8e, 0xe3, 0x38, 0x8e, 0xe3, 0x38, 0x0e, 0x38, 0x8e, 0xe3, 0x38, 0x8e, 0xe3, 0x38, 0x0e, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xff, 0x9f, 0x0f, 0x9f, 0x1f, 0x7e, 0xf8, 0x07, 0xff, 0xbf, 0x0f, 0x9f, 0x3f, 0x7f, 0xf8, 0x07, 
  0x1f, 0xbe, 0x0f, 0x9f, 0xff, 0x7f, 0x3c, 0x0f, 0x1f, 0xbe, 0x0f, 0x9f, 0xff, 0x7f, 0x3c, 0x0f, 
  0xff, 0xbf, 0x0f, 0x9f, 0xff, 0x7f, 0xfe, 0x1f, 0xff, 0xbf, 0x0f, 0x9f, 0xf7, 0x7b, 0xfe, 0x1f, 
  0xff, 0x9f, 0x9f, 0x9f, 0xf7, 0x7b, 0xff, 0x3f, 0x1f, 0x00, 0xff, 0x9f, 0xe7, 0x79, 0x0f, 0x3c, 
  0x1f, 0x00, 0xff, 0x8f, 0xe7, 0x78, 0x0f, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x8e, 0xe3, 0x38, 0x8e, 0xe3, 0x38, 0x0e, 
  0x38, 0x8e, 0xe3, 0x38, 0x8e, 0xe3, 0x38, 0x0e, 0x38, 0x8e, 0xe3, 0x38, 0x8e, 0xe3, 0x38, 0x0e, 
  0xc7, 0x71, 0x1c, 0xc7, 0x71, 0x1c, 0xc7, 0x71, 0xc7, 0x71, 0x1c, 0xc7, 0x71, 0x1c, 0xc7, 0x71, 
  0xc7, 0x71, 0x1c, 0xc7, 0x71, 0x1c, 0xc7, 0x71
};

const unsigned char logoPuma48 [] PROGMEM = {
0x30, 0xFF, 0x0C, 0x30, 0xFF, 0x0C, 0x0C, 0xCC, 0x30, 0x0C, 0xCC, 0x30, 0x30, 0xCC, 0x0C, 0x30,
0xCC, 0x0C, 0x0C, 0xCC, 0x30, 0x0C, 0xCC, 0x30, 0x30, 0xCC, 0x0C, 0x30, 0xFC, 0x0C, 0x0C, 0x78,
0x30, 0x0C, 0x00, 0x30, 0x30, 0xFE, 0x0C, 0x30, 0xFF, 0x0C, 0x0C, 0x03, 0x30, 0x0C, 0x03, 0x30,
0x30, 0x03, 0x0C, 0x30, 0x03, 0x0C, 0x0C, 0x03, 0x30, 0x0C, 0x03, 0x30, 0x30, 0x03, 0x0C, 0x30,
0xFF, 0x0C, 0x0C, 0xFE, 0x30, 0x0C, 0x00, 0x30, 0x30, 0xFF, 0x0C, 0x30, 0xFF, 0x0C, 0x0C, 0xE0,
0x30, 0x0C, 0x78, 0x30, 0x30, 0x1E, 0x0C, 0x30, 0x07, 0x0C, 0x0C, 0x1E, 0x30, 0x0C, 0x78, 0x30,
0x30, 0xE0, 0x0C, 0x30, 0xFF, 0x0C, 0x0C, 0xFF, 0x30, 0x0C, 0x00, 0x30, 0x30, 0x03, 0x0C, 0x30,
0x0F, 0x0C, 0x0C, 0x3E, 0x30, 0x0C, 0xFC, 0x30, 0x30, 0xEC, 0x0C, 0x30, 0xCC, 0x0C, 0x0C, 0xCC,
0x30, 0x0C, 0xEC, 0x30, 0x30, 0xFC, 0x0C, 0x30, 0x3E, 0x0C, 0x0C, 0x0F, 0x30, 0x0C, 0x03, 0x30
};

// 'n0', 36x24px
const unsigned char n0 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x1f, 0x00, 0x00, 
  0xfe, 0xff, 0x7f, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0xff, 0x01, 0xc0, 0xff, 
  0xff, 0xff, 0x03, 0xe0, 0xdf, 0x07, 0xfc, 0x03, 0xe0, 0x87, 0x0f, 0xe0, 0x07, 0xe0, 0x03, 0x1f, 
  0xc0, 0x07, 0xe0, 0x01, 0x1e, 0xc0, 0x07, 0xe0, 0x01, 0x3e, 0xc0, 0x07, 0xe0, 0x01, 0x7c, 0xc0, 
  0x07, 0xe0, 0x03, 0xf8, 0xc0, 0x07, 0xe0, 0x07, 0xf0, 0xe0, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x03, 
  0xc0, 0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0x01, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 
  0xfe, 0xff, 0x3f, 0x00, 0x00, 0xf8, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'n1', 36x24px
const unsigned char n1 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 
  0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 
  0xf8, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0xe0, 0xff, 0xff, 0xff, 
  0x01, 0xe0, 0xff, 0xff, 0xff, 0x01, 0xe0, 0xff, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0xff, 0x03, 
  0xe0, 0xff, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'n2', 36x24px
const unsigned char n2 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xe0, 0x03, 0x00, 0x3e, 0x00, 0xe0, 
  0x07, 0x00, 0x7e, 0x00, 0xe0, 0x0f, 0x00, 0xfe, 0x00, 0xe0, 0x1f, 0x00, 0xfe, 0x01, 0xe0, 0x3f, 
  0x00, 0xfe, 0x03, 0xe0, 0x7f, 0x00, 0xf0, 0x03, 0xe0, 0xff, 0x00, 0xe0, 0x03, 0xe0, 0xff, 0x01, 
  0xc0, 0x07, 0xe0, 0xfb, 0x03, 0xc0, 0x07, 0xe0, 0xf3, 0x07, 0xc0, 0x07, 0xe0, 0xe3, 0x1f, 0xc0, 
  0x07, 0xe0, 0x83, 0x3f, 0xe0, 0x07, 0xe0, 0x03, 0xff, 0xf0, 0x03, 0xe0, 0x03, 0xfe, 0xff, 0x03, 
  0xe0, 0x03, 0xfc, 0xff, 0x01, 0xe0, 0x03, 0xf8, 0xff, 0x01, 0xe0, 0x03, 0xf0, 0xff, 0x00, 0xe0, 
  0x03, 0xc0, 0x3f, 0x00, 0xe0, 0x03, 0x00, 0x0e, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'n3', 36x24px
const unsigned char n3 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x3c, 0x00, 0x00, 
  0x3f, 0x00, 0x7c, 0x00, 0x80, 0x3f, 0x00, 0xfc, 0x00, 0xc0, 0x3f, 0x00, 0xfc, 0x01, 0xc0, 0x3f, 
  0x00, 0xfc, 0x03, 0xe0, 0x07, 0x00, 0xf8, 0x03, 0xe0, 0x03, 0x3c, 0xe0, 0x07, 0xe0, 0x03, 0x3c, 
  0xc0, 0x07, 0xe0, 0x01, 0x3c, 0xc0, 0x07, 0xe0, 0x01, 0x3c, 0xc0, 0x07, 0xe0, 0x01, 0x7c, 0xc0, 
  0x07, 0xe0, 0x03, 0x7e, 0xc0, 0x07, 0xe0, 0x03, 0xfe, 0xe0, 0x07, 0xe0, 0x8f, 0xff, 0xff, 0x03, 
  0xc0, 0xff, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xff, 0xff, 0x01, 0x80, 0xff, 0xe7, 0xff, 0x00, 0x00, 
  0xff, 0xc3, 0x7f, 0x00, 0x00, 0xfc, 0x01, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'n4', 36x24px
const unsigned char n4 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x03, 0x00, 0x00, 0x00, 
  0xf8, 0x07, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0x00, 0xf8, 
  0xff, 0x00, 0x00, 0x00, 0xf8, 0xfe, 0x03, 0x00, 0x00, 0xf8, 0xf8, 0x07, 0x00, 0x00, 0xf8, 0xe0, 
  0x1f, 0x00, 0x00, 0xf8, 0xc0, 0x3f, 0x00, 0x00, 0xf8, 0x00, 0xff, 0x00, 0x00, 0xf8, 0x00, 0xfe, 
  0x01, 0xe0, 0xff, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x07, 
  0xe0, 0xff, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x07, 0x00, 
  0xf8, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'n5', 36x24px
const unsigned char n5 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 
  0x3f, 0xf8, 0x1f, 0x00, 0x80, 0x3f, 0xf8, 0xff, 0x07, 0x80, 0x3f, 0xf8, 0xff, 0x07, 0xc0, 0x3f, 
  0xfc, 0xff, 0x07, 0xc0, 0x0f, 0xf8, 0xff, 0x07, 0xe0, 0x03, 0xf0, 0xfc, 0x07, 0xe0, 0x03, 0xf0, 
  0xc1, 0x07, 0xe0, 0x03, 0xf0, 0xc1, 0x07, 0xe0, 0x03, 0xf0, 0xc1, 0x07, 0xe0, 0x03, 0xf0, 0xc1, 
  0x07, 0xe0, 0x03, 0xf0, 0xc1, 0x07, 0xe0, 0x07, 0xf8, 0xc1, 0x07, 0xc0, 0xbf, 0xff, 0xc0, 0x07, 
  0xc0, 0xff, 0xff, 0xc0, 0x07, 0x80, 0xff, 0x7f, 0xc0, 0x07, 0x00, 0xff, 0x3f, 0xc0, 0x07, 0x00, 
  0xfe, 0x1f, 0xc0, 0x07, 0x00, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'n6', 36x24px
const unsigned char n6 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x01, 0x00, 0x00, 
  0xfe, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x00, 0x80, 0xff, 0xff, 0x3f, 0x00, 0xc0, 0xff, 
  0xff, 0x7f, 0x00, 0xc0, 0x1f, 0xfc, 0xff, 0x00, 0xe0, 0x07, 0xf8, 0xfc, 0x01, 0xe0, 0x03, 0xf0, 
  0xf0, 0x01, 0xe0, 0x03, 0xf0, 0xf1, 0x03, 0xe0, 0x03, 0xf0, 0xe1, 0x03, 0xe0, 0x03, 0xf0, 0xe1, 
  0x03, 0xe0, 0x03, 0xf0, 0xc1, 0x07, 0xe0, 0x07, 0xf8, 0xc1, 0x07, 0xc0, 0x1f, 0xff, 0xc1, 0x07, 
  0xc0, 0xff, 0xff, 0xc0, 0x07, 0x80, 0xff, 0x7f, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 
  0xfe, 0x1f, 0x00, 0x00, 0x00, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'n7', 36x24px
const unsigned char n7 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x00, 
  0x00, 0x00, 0xc0, 0x07, 0x20, 0x00, 0x00, 0xc0, 0x07, 0xe0, 0x00, 0x00, 0xc0, 0x07, 0xe0, 0x03, 
  0x00, 0xc0, 0x07, 0xe0, 0x0f, 0x00, 0xc0, 0x07, 0xe0, 0x3f, 0x00, 0xc0, 0x07, 0xe0, 0xff, 0x00, 
  0xc0, 0x07, 0xc0, 0xff, 0x07, 0xc0, 0x07, 0x00, 0xff, 0x1f, 0xc0, 0x07, 0x00, 0xfc, 0x7f, 0xc0, 
  0x07, 0x00, 0xe0, 0xff, 0xc1, 0x07, 0x00, 0x80, 0xff, 0xc7, 0x07, 0x00, 0x00, 0xfe, 0xdf, 0x07, 
  0x00, 0x00, 0xf0, 0xff, 0x07, 0x00, 0x00, 0xc0, 0xff, 0x07, 0x00, 0x00, 0x00, 0xff, 0x07, 0x00, 
  0x00, 0x00, 0xfc, 0x07, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'n8', 36x24px
const unsigned char n8 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x01, 0x1e, 0x00, 0x00, 
  0xff, 0xc3, 0x7f, 0x00, 0x80, 0xff, 0xe7, 0xff, 0x00, 0xc0, 0xff, 0xff, 0xff, 0x01, 0xc0, 0xff, 
  0xff, 0xff, 0x03, 0xe0, 0x8f, 0xff, 0xff, 0x03, 0xe0, 0x03, 0xfe, 0xe0, 0x07, 0xe0, 0x03, 0x7e, 
  0xc0, 0x07, 0xe0, 0x01, 0x7c, 0xc0, 0x07, 0xe0, 0x01, 0x7c, 0xc0, 0x07, 0xe0, 0x01, 0x7c, 0xc0, 
  0x07, 0xe0, 0x03, 0x7e, 0xc0, 0x07, 0xe0, 0x03, 0xfe, 0xf0, 0x07, 0xe0, 0xdf, 0xff, 0xff, 0x03, 
  0xc0, 0xff, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xef, 0xff, 0x01, 0x80, 0xff, 0xc7, 0xff, 0x00, 0x00, 
  0xff, 0x83, 0x7f, 0x00, 0x00, 0xfc, 0x01, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'n9', 36x24px
const unsigned char n9 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x1f, 0x00, 0x00, 
  0x00, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0xe0, 0x83, 
  0xff, 0xff, 0x03, 0xe0, 0x83, 0x7f, 0xfc, 0x03, 0xe0, 0xc3, 0x0f, 0xe0, 0x03, 0xe0, 0xc3, 0x07, 
  0xc0, 0x07, 0xe0, 0xc3, 0x07, 0xc0, 0x07, 0xe0, 0xc7, 0x07, 0xc0, 0x07, 0xc0, 0x87, 0x07, 0xc0, 
  0x07, 0xc0, 0x8f, 0x0f, 0xe0, 0x07, 0x80, 0x9f, 0x0f, 0xf0, 0x03, 0x80, 0xff, 0x3f, 0xff, 0x03, 
  0x00, 0xff, 0xff, 0xff, 0x01, 0x00, 0xfe, 0xff, 0xff, 0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00, 
  0xf0, 0xff, 0x3f, 0x00, 0x00, 0x80, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


const int allNumbers_LEN = 10;
const unsigned char* allNumbers[10] = {
  n0,
  n1,
  n2,
  n3,
  n4,
  n5,
  n6,
  n7,
  n8,
  n9
};

int rpmGraph[48];


int led = D2;
bool ledState = false;
//int rpm = 6;
int signalRead = 0;

int minSignalRead = 4095;
int maxSignalRead = 0;
int rpmValueLimit = 2048;
bool rpmFlipFlop = false;
int avgRpmValue = 0;
int rpmValueCount = 0;
int rpmValueCountToDisplay = 0;
int rpmIdealCalc = 0;
int lowRpm = 0;
int avgRound = 0;
int avgFiltered = 0;

long timmer = 0;
long timmerTela = 0;
int refreshTime = 100; //tempo que somará o número de pulsos para cálculo do RPM. Padrão 100ms
int contadorTela = 0; //para diminuir a velocidade de exibição na tela
int tempRpm = 0; //Calcula a media de X RPMs para exibir apos X tempos do refreshTime
int displayRpm = 0; //armazena um valor para exibir apos X tempos do refreshTime

// Mensagem de telemetria

typedef struct puma_rpm {
    int value;
} puma_rpm;

puma_rpm pumaData2;

// Mensagem de telemetria
typedef struct puma_telemetry {
    int velValue;
    int tempValue;
    int tempMotorValue;
    bool sinalValue;
    bool luzBaixaValue;
    bool luzAltaValue;
    int minutoValue;
    int horaValue;
} puma_telemetry;

puma_telemetry pumaData;

//Endereco MAC: 48:55:19:00:50:DE
uint8_t broadcastAddress[] = {0x48, 0x55, 0x19, 0x00, 0x50, 0xDE};

int velocidade = 0;

void OnDataRecv(uint8_t * mac, uint8_t *incomingData, uint8_t len){
  memcpy(&pumaData, incomingData, sizeof(pumaData));
  velocidade = pumaData.velValue;
}

/*
void OnDataSent(uint8_t *mac_addr, uint8_t sendStatus) {
  ledState = !ledState;
  digitalWrite(led, ledState);
}
*/

//cálculo do RPM ideal
float relacao[4] = {3.8,2.06,1.32,0.89};
int ideal[4] = {0,0,0,0};
float diferencial = 4.125;
int pneus = 195;
int largura = 70;
int aro = 14;
float valorExtra = 0.045;
int marcha = 0;

int rpmIdeal(){
  int rpmMin = 9999;
  int marchaIdeal = 0;
  for(int i=0;i<4;i++){
    ideal[i] = (1000 * relacao[i] * diferencial * velocidade)/(60 * 3.1416 * (pneus * largura * (2/100000) + aro * valorExtra));
    if(ideal[i]<850) ideal[i] = 9999;
  }
  for(int i=0;i<4;i++){
    if(ideal[i] < rpmMin){
      rpmMin = ideal[i];
      marchaIdeal = i;
    }
  }
  return marchaIdeal;
}


void setup() {
  //pinMode(rpm, INPUT);
  pinMode(led, OUTPUT);
  strip.begin();
  strip.show();
  strip.setBrightness(3);
  display.init();
  display.setColor(WHITE);
  //display.flipScreenVertically();
  display.setContrast(255);
  //display.drawXbm(32, 30, logoPuma64_width, logoPuma64_height, logoPuma64);
  display.drawXbm(52, 0, 24, 48 , logoPuma48);
  display.display();
  //delay(2000);
  //motor1.zero();
  for(int i=0;i<19;i++){
    strip.setPixelColor(i, strip.Color(0,   255,   0));
    strip.show();
    motor1.setPosition((18-i)*52);
    for(int y=0;y<200;y++){
      motor1.update();
      delay(1);
    }
  }
  if(espnowIsOn){
    WiFi.mode(WIFI_STA);
    if (esp_now_init() != 0) {
      display.setTextAlignment(TEXT_ALIGN_CENTER);
      display.setFont(ArialMT_Plain_10);
      display.clear();
      display.drawString(64, 30, "ESPNOW");
      display.drawString(64, 42, "ERROR!");
      display.display();
      delay(2000);
      return;
    }
    esp_now_set_self_role(ESP_NOW_ROLE_SLAVE);
    esp_now_register_recv_cb(OnDataRecv);
  } else {
    display.setTextAlignment(TEXT_ALIGN_CENTER);
    display.setFont(ArialMT_Plain_10);
    display.clear();
    display.drawString(64, 30, "ESPNOW");
    display.drawString(64, 42, "OFF");
    display.display();
    delay(2000);
  }
  ledsRpmZero();
  //delay(1000);
  if(testIsOn) delay(500);
}


void loop() {
  if(timmerTela<millis()){
    timmerTela = millis() + 500;
    display.clear();
    if(debugIsOn){
      display.setTextAlignment(TEXT_ALIGN_LEFT);
      display.setFont(ArialMT_Plain_10);
      display.drawString(32, 0, (String)rpmFiltered);
      display.drawString(65, 0, ": " + (String)dezena(rpmFiltered) + (String)unidade(rpmFiltered));
      display.drawString(32, 13, (String)rpmValueCountToDisplay + " a cada " + (String)refreshTime);
      display.drawString(32, 26, (String)minSignalRead);
      display.drawString(50, 26, (String)rpmValueLimit);
      display.drawString(70, 26, (String)maxSignalRead);
      //display.drawString(32, 38, "Filter: " + (String)rpmFiltered);
      //display.drawString(32, 58, (String)signalRead);
    } else {
      display.drawXbm(60, 0, 36, 24 , allNumbers[dezena(tempRpm)]);
      display.drawXbm(60, 24, 36, 24 , allNumbers[unidade(tempRpm)]);
      rpmGraphInput(avgRound);
      rpmGraphPrint();
    }
    display.display();
    //displayRpm = tempRpm;
    tempRpm = avgFiltered;
  }
  if(timmer<millis()){
    timmer = millis() + refreshTime;
    //calcula o rpm
    if(testIsOn){
      avgRpmValue = avgRpmValue + (random(500)-200);
      if(avgRpmValue<0) avgRpmValue = 0;
      if(avgRpmValue>47000) avgRpmValue = 47000;
    } else {
      avgRpmValue = rpmValueCount * (60*refreshTime)/4; //calcula quantas vezes o RPM é calculado em um minuto
    }
    rpmFiltered = filtroRpm.updateEstimate(avgRpmValue);

    marcha = rpmIdeal();
    rpmIdealCalc = ideal[marcha];
    
    //dá o RPm com dois dígitos
    avgRound = avgRpmValue/1000;
    avgFiltered = rpmFiltered/1000;
    if(avgRound>99) avgRound = 99;
    //dá o RPM ideal de acordo com a velocidade
    int idealRound = rpmIdealCalc/100;
    //liga os leds
    ledsRpm(avgRound,idealRound);
    tempRpm = (tempRpm + avgFiltered)/2; //calcula a média das leituras

    //zera os dados de contador do sinal de RPM
    rpmValueCountToDisplay = rpmValueCount;
    rpmValueCount = 0;
    //minSignalRead = 1023;
    //maxSignalRead = 0;
    //rpmValueLimit = 512;
    
  }
  rpmCalc();
  if(ponteiro<rpmFiltered){
    ponteiro = ponteiro + elasticidade;
  } else {
    if(ponteiro>rpmFiltered){
      ponteiro = ponteiro - elasticidade;
    }
  }
  motor1.setPosition(map(ponteiro,0,47000,0,800));
  motor1.update();
}

int dezena(int numero){
  return avgRound/10;
}

int unidade(int numero){
  int dezena = avgRound/10;
  return avgRound - (dezena * 10); 
}

void exibeDisplay(int rpmDisplay, int marchaDisplay, String texto){
  display.clear();
  display.setTextAlignment(TEXT_ALIGN_CENTER);
  display.setFont(Orbitron_Medium_17);
  display.fillRect(32,50,16,16);
  display.drawString(72, 50, texto);
  display.setColor(BLACK);
  if(marchaDisplay==0){
    display.drawString(40, 50, "N");
  } else {
    display.drawString(40, 50, (String)marchaDisplay);
  }
  display.setColor(WHITE);
  display.setFont(Orbitron_Medium_38);
  display.drawString(64, 16, (String)rpmDisplay);
}

void ledsRpmZero(){
  apagaLeds();
  strip.setPixelColor(17, strip.Color(255,   0,   0));
  strip.show();
}

void apagaLeds(){
  for(int i=0;i<18;i++){
      strip.setPixelColor(i, strip.Color(0,   0,   0));
  }
  strip.show();
}

void ledsRpm(int medido, int ideal){
  int ligados = map(medido,0,42,17,0);
  int marcacaoIdeal = map(ideal,0,42,17,0);
  int marcasVermelhas = 255;
  for(int i=18;i>=0;i--){
    if(i<10) {
      marcasVermelhas = marcasVermelhas - 70;
      if(marcasVermelhas<0) marcasVermelhas = 0;
    }
    if(i>ligados){
      strip.setPixelColor(i, strip.Color(255,   marcasVermelhas,   marcasVermelhas));
    } else {
      strip.setPixelColor(i, strip.Color(0,   0,   0));
    }
    if(marcacaoIdeal!=0) {
      if(marcacaoIdeal>ligados){
        strip.setPixelColor(marcacaoIdeal, strip.Color(180,   64,   16));
      } else {
        strip.setPixelColor(marcacaoIdeal, strip.Color(0,   255,   0));
      }
      
    }
    if(medido == 0) ledsRpmZero();
    strip.show();
  }
}

void rpmCalc(){
  //encontra os valores analógicos do optoacoplador e marca as mudanças do sinal
  signalRead = analogRead(A0);
  //calcula os limites do valor lido
  if(signalRead<minSignalRead) minSignalRead = signalRead;
  if(signalRead>maxSignalRead) maxSignalRead = signalRead;
  //calcula o limite médio
  rpmValueLimit = (minSignalRead + maxSignalRead)/2;
  if(rpmValueLimit>128){
    if((signalRead<rpmValueLimit)!=rpmFlipFlop){
      rpmValueCount++;
      rpmFlipFlop = !rpmFlipFlop;
    }
  }
}

void rpmGraphInput(int valor){
  for(int i=0;i<47;i++){
    rpmGraph[i] = rpmGraph[i+1];
  }
  rpmGraph[47] = valor;
}

void rpmGraphPrint(){
  for(int i=0;i<48;i++){
    display.drawLine(32,i,map(rpmGraph[i],0,46,32,70),i);
  }
}
